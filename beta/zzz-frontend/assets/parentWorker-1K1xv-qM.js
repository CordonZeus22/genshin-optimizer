(function(){"use strict";const E=function*(e,t,a){for(let s=e;s<=t;s+=a)yield s};function h(e,t,a=1){return[...E(e,t,a)]}function g(e,t){return Object.fromEntries(e.map((a,s)=>[a,t(a,s)]))}const S=["1","2","3","4","5","6"],A=["hp","atk","def","hp_","atk_","def_","pen","crit_","crit_dmg_","anomProf"],B=["hp","atk","def","hp_","atk_","def_","crit_","crit_dmg_","anomProf",...["electric_dmg_","fire_dmg_","ice_dmg_","physical_dmg_","ether_dmg_"],"pen_","anomMas_","impact_","enerRegen_"];Array.from(new Set([...A,...B]));const R={hp:{B:39,A:79,S:112},atk:{B:7,A:15,S:19},def:{B:5,A:10,S:15},hp_:{B:.01,A:.02,S:.03},atk_:{B:.01,A:.02,S:.03},def_:{B:.016,A:.032,S:.048},pen:{B:3,A:6,S:9},crit_:{B:.008,A:.016,S:.024},crit_dmg_:{B:.016,A:.032,S:.048},anomProf:{B:3,A:6,S:9}};function M(e,t){return R[e][t]}const o={B:.1,A:.2,S:.3},b={atk_:o,hp_:o,def_:{B:.16,A:.32,S:.48},hp:{B:734,A:1468,S:2200},atk:{B:104,A:212,S:316},def:{B:60,A:124,S:184},anomProf:{B:32,A:60,S:92},crit_:{B:.08,A:.16,S:.24},crit_dmg_:{B:.16,A:.32,S:.48},pen_:{B:.08,A:.16,S:.24},electric_dmg_:o,fire_dmg_:o,ice_dmg_:o,physical_dmg_:o,ether_dmg_:o,anomMas_:o,enerRegen_:{B:.2,A:.4,S:.6},impact_:{B:.06,A:.12,S:.18}};function k(e,t,a){return b[t][e]??0}const K=["charLvl","enemyDef","enemyDefRed_","enemyRes_","enemyResRed_","enemyResIgn_","dmg_","impact","anomMas","shield_"];Array.from(new Set([...B,...A,...K])),{...g(["burn","shock","corruption","shatter","assault"],e=>`${e} DMG Bonus`)},Object.entries({electric:"Electric",fire:"Fire",ice:"Ice",physical:"Physical",ether:"Ether"}).forEach(([e,t])=>{});const f=5e4;function P(e){const{id:t,mainStatKey:a,level:s,rarity:c,setKey:m,substats:y}=e;return{id:t,stats:{[a]:k(c,a),...Object.fromEntries(y.map(({key:_,upgrades:i})=>[_,M(_,c)*i])),[m]:1}}}let u;onmessage=async e=>{try{await T(e)}catch(t){console.error(t),postMessage({resultType:"err",message:JSON.stringify(t)})}};async function T(e){const{data:t}=e,{command:a}=t;switch(a){case"start":await C(t);break;case"terminate":F();break}}async function C({baseStats:e,discsBySlot:t,constraints:a,numWorkers:s,formulaKey:c}){const m=g(S,n=>t[n].map(P)),{largestSlot:y}=Object.entries(t).reduce(({largestSlot:n,largestSize:r},[d,l])=>l.length>r?{largestSlot:d,largestSize:l.length}:{largestSlot:n,largestSize:r},{largestSlot:"head",largestSize:-1}),_=h(0,s-1).map(n=>g(S,r=>r===y?m[r].filter((d,l)=>l%s===n):m[r]));u=h(1,s).map(()=>new Worker(new URL(""+new URL("childWorker-ColXrp2h.js",self.location.href).href,self.location.href),{type:"module"}));let i=[],D=0;postMessage({resultType:"progress",progress:{numBuildsKept:0,numBuildsComputed:0}}),await Promise.all(u.map((n,r)=>new Promise((d,l)=>{n.onmessage=({data:p})=>{switch(p.resultType){case"initialized":n.postMessage({command:"start"});break;case"results":D+=p.numBuildsComputed,i=i.concat(p.builds),i.length>f*4&&(i.sort((I,w)=>w.value-I.value),i=i.slice(0,f)),postMessage({resultType:"progress",progress:{numBuildsKept:Math.min(i.length,f),numBuildsComputed:D}});break;case"done":d();break;case"err":console.error(p),l();break}};const v={command:"init",baseStats:e,discStatsBySlot:_[r],constraints:a,formulaKey:c};n.postMessage(v)}))),postMessage({resultType:"done",buildResults:i.sort((n,r)=>r.value-n.value).slice(0,10)})}function F(){u.forEach(e=>e.terminate()),postMessage({resultType:"terminated"})}})();
