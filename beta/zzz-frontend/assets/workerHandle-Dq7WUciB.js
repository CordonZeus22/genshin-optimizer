(function(){"use strict";const O={};class _{constructor(){this.internal=new j}ref(e){return e.reduce((o,a)=>o.get(a),this.internal)}*[Symbol.iterator](){for(const[e,o]of this.internal.entries([]))"value"in o&&(yield[[...e],o.value])}*values(){for(const e of this.internal.allRefs())"value"in e&&(yield e.value)}}class j{constructor(){this.map=new Map}get(e){const o=this.map.get(e);if(o)return o;const a=new j;return this.map.set(e,a),a}*allRefs(){for(const e of this.map.values())yield*e.allRefs();yield this}*entries(e){const o=e.push(void 0)-1;for(const[a,t]of this.map.entries())e[o]=a,yield*t.entries(e);e.pop(),yield[e,this]}}function N(s){throw new Error(`Should not reach this with value ${s}`)}const V={sum:s=>s.reduce((e,o)=>e+o,0),prod:s=>s.reduce((e,o)=>e*o,1),min:s=>Math.min(...s),max:s=>Math.max(...s),sumfrac:([s,e])=>s/(s+e),unique:([s])=>s},X={match:([s,e])=>s===e?0:1,thres:([s,e])=>s>=e?0:1,lookup:([s],e)=>e[s]??0},q=Object.freeze([]),R=Object.freeze([]);function y(s){return{op:"const",x:q,br:R,ex:s}}const D=(...s)=>C("sum",s),F=(...s)=>C("min",s),J=(...s)=>C("max",s);function C(s,e){return{op:s,x:U(e),br:R}}function L(s,e){return{op:"read",x:q,br:R,tag:s,ex:e}}function U(s){return s.map(G)}function G(s){return typeof s=="number"||typeof s=="string"?y(s):s}function v(s,e){const o=new Map;function a(t){const f=o.get(t);if(f)return f;const u=t,r=S(t.x,a),l=S(t.br,a);(t.x!==r||t.br!==l)&&(t={...t,x:r,br:l});const c=e(t,u);return o.set(t,c),c}return S(s,a)}function E(s,e){const o=new Set;function a(t){o.has(t)||(e(t,a),o.add(t))}s.forEach(a)}function S(s,e){const o=s.map(e);return s.every((a,t)=>a===o[t])?s:o}function H(s,e,o,a){let t="'use strict';const _=0";for(const[r,l]of Object.entries(O))t+=`,f${r}=${l.calc.toString()}`;const{str:f,names:u}=Q(s,e,o,a);return t+=`${f};return[${s.map(r=>u.get(r))}]`,new Function("b",t)}function Q(s,e,o,a){let t="";const f=new Map;return E(s,(u,r)=>{const{op:l}=u;u.x.forEach(r),u.br.forEach(r);const c=u.x.map(n=>f.get(n)),m=u.br.map(n=>f.get(n)),i=`x${f.size}`;switch(f.set(u,i),l){case"const":t+=`,${i}=`+(typeof u.ex!="string"?u.ex:`'${u.ex}'`);break;case"sum":case"prod":t+=`,${i}=`,c.length?t+=c.join(l=="sum"?"+":"*"):t+=l=="sum"?0:1;break;case"min":case"max":t+=`,${i}=Math.${l}(${c})`;break;case"sumfrac":t+=`,${i}=${c[0]}/(${c[0]}+${c[1]})`;break;case"match":t+=`,${i}=${m[0]}===${m[1]}?${c[0]}:${c[1]}`;break;case"thres":t+=`,${i}=${m[0]}>=${m[1]}?${c[0]}:${c[1]}`;break;case"read":{const n=u.tag[e];let h=[...new Array(o)].map((p,d)=>`(b[${d}]['${n}'] ?? 0)`);a[n]&&(h=[a[n].toString(),...h]),t+=`,${i}=+(${h.join("+")}+0)`;break}case"subscript":t+=`,${i}=${JSON.stringify(u.ex)}[${m[0]}]`;break;case"custom":t+=`,${i}=f${u.ex}([${c}])`;break;case"lookup":t+=`,${i}=([${c}])[(${JSON.stringify(u.ex)})[${m[0]}]??0]`;break;default:N(l)}}),{str:t,names:f}}const z={arithmetic:V,branching:X},{arithmetic:T}=z;function Y(s){return s=Z(s),s=K(s),s=ee(s),s}function Z(s){return v(s,e=>{const{op:o}=e;switch(o){case"sum":case"prod":case"min":case"max":if(e.x.length===1)return e.x[0];if(e.x.some(a=>a.op===o)){const a=e.x.flatMap(t=>t.op===o?t.x:[t]);return{...e,x:a}}}return e})}function K(s){return v(s,e=>{const{op:o}=e;switch(o){case"sum":case"prod":case"min":case"max":{const a=e.x.filter(t=>t.op==="const");if(a.length>1){const t=e.x.filter(u=>u.op!=="const"),f=T[o](a.map(u=>u.ex),e.ex);return f===T[o]([],e.ex)?{...e,x:t}:{...e,x:[y(f),...t]}}}}return e})}function ee(s){const e=new Map,o=new _;return v(s,a=>{const{op:t}=a,f=a.x.map(c=>e.get(c)),u=a.br.map(c=>e.get(c));let r;switch(t){case"read":{const c=Object.keys(a.tag).sort();r=[t,a.ex,...c,...c.map(m=>a.tag[m])];break}case"sum":case"prod":case"min":case"max":r=[t,...f.sort()];break;case"thres":case"custom":case"sumfrac":case"lookup":case"subscript":case"const":r=[t,a.ex,...f,...u];break;case"match":r=[t,a.ex,...f,...u.sort()];break;default:N(t)}const l=o.ref(r);return"value"in l?l.value:(l.value=a,e.set(a,e.size),a)})}const{arithmetic:te,branching:se}=z;function ne(s,e,o,a,t){const f=new re(s,a,e,o);for(;f.progress;)f.progress=!1,oe(f),ie(f,1),ce(f),ae(f,t);return f.setNodes(Y(f.nodes)),f}class re{constructor(e,o,a,t){this.progress=!0,this.nodes=e,this.minimum=o,this.candidates=a,this.cat=t}setNodes(e,o){this.nodes!==e&&(this.progress=!0,this.nodes=e,o!==void 0&&(this.minimum=o),this._nodeRanges=void 0,this._monotonicities=void 0)}setCandidates(e,o){this.candidates!==e&&(this.progress=!0,this.candidates=e,this._cndRanges=o,this._nodeRanges=void 0,this._monotonicities=void 0)}get cndRanges(){return this._cndRanges??(this._cndRanges=this.candidates.map(I))}get nodeRanges(){return this._nodeRanges??(this._nodeRanges=W(this.nodes,this.cat,this.cndRanges))}get monotonicities(){return this._monotonicities??(this._monotonicities=ue(this.nodes.slice(0,this.minimum.length),this.cat,this.nodeRanges))}}function oe(s){const{nodes:e,nodeRanges:o}=s,a=v(e,(t,f)=>{const u=o.get(f);if(u.min===u.max)return f.op==="const"?t:y(u.min);switch(f.op){case"thres":{const[r,l]=f.br.map(c=>o.get(c));if(r.min>=l.max)return t.x[0];if(r.max<l.min)return t.x[1];break}case"min":{const r=t.x.filter((l,c)=>o.get(f.x[c]).min<=u.max);if(r.length===1)return r[0];if(r.length!==t.x.length)return F(...r);break}case"max":{const r=t.x.filter((l,c)=>o.get(f.x[c]).max>=u.min);if(r.length===1)return r[0];if(r.length!==t.x.length)return J(...r);break}case"match":case"lookup":if(t.br.every(r=>r.op==="const")){const r=t.br.map(l=>l.ex);return t.x[se[f.op](r,f.ex)]}break;case"subscript":if(t.br[0].op==="const")return y(t.ex[t.br[0].ex]);break}return t});s.setNodes(a)}function ie(s,e){const{nodeRanges:o,minimum:a,cat:t}=s,f=[...s.candidates],u=[...s.cndRanges],r=[],l=[];let c=!1;if(s.nodes.forEach((i,n)=>{if(n<a.length){if(a[n]>o.get(i).min)c=!0;else if(n>=e)return;l.push(a[n])}r.push(i)}),l.length!=a.length&&s.setNodes(r,l),!c)return;let m=!1;f.forEach((i,n)=>{const h=u[n],p=i.filter(d=>{u[n]=I([d]);const g=W(r,t,u);return l.every((x,b)=>g.get(r[b]).max>=x)});p.length!=i.length?(f[n]=p,u[n]=I(p),m=!0):u[n]=h}),m&&s.setCandidates(f,u)}function ae(s,e){const o=[...s.monotonicities],a=s.candidates.map(c=>c.map(m=>{const i={incomp:[],inc:{},c:m};for(const[n,h]of o)h.inc?i.inc[n]=m[n]??0:h.dec?i.inc[n]=-(m[n]??0):i.incomp.push(m[n]??0);return i})),t=a[0][0];if(t===void 0)return;const f=Object.keys(t.inc),u=[...f].reverse(),r=!!t.incomp.length,l=a.map(c=>{const m=new _;return r?c.forEach(i=>{const n=m.ref(i.incomp);n.value?n.value.push(i):n.value=[i]}):m.ref([]).value=c,[...m.values()].flatMap(i=>(i.sort(({inc:n},{inc:h})=>{const p=u.find(d=>n[d]!==h[d]);return p===void 0?0:h[p]-n[p]}),i.filter(({inc:n},h)=>{let p=0;for(let d=0,g=h-e;d<=g+p;d++){const x=i[d].inc;if(f.every(b=>x[b]>=n[b])&&++p>=e)return!1}return!0})))});l.some((c,m)=>c.length!=s.candidates[m].length)&&s.setCandidates(l.map(c=>c.map(m=>m.c)))}const w=Symbol();function ce(s){const{nodes:e,cat:o,candidates:a}=s,t=new Map;E(e,(n,h)=>{if(n.x.forEach(h),n.br.forEach(h),n.br.length)return;const p=n.x.map(g=>t.get(g));if(p.some(g=>!g))return;let d;switch(n.op){case"sum":{d={[w]:p.reduce((g,x)=>g+x[w],0)};for(const g of p)for(const[x,b]of Object.entries(g))d[x]=(d[x]??0)+b;break}case"prod":{const g=n.x.findIndex(b=>b.op!=="const");if(n.x.find((b,$)=>b.op!=="const"&&$!==g))return;d={...p[g]};const x=p.reduce((b,$,ge)=>ge===g?b:b*$[w],1);x!=1&&(Object.keys(d).forEach(b=>d[b]*=x),d[w]*=x);break}case"read":d={[n.tag[o]]:1,[w]:0};break;case"const":if(typeof n.ex!="number")return;d={[w]:n.ex};break;default:return}t.set(n,d)});const f=new Map;E(e,(n,h)=>{const p=t.get(n);p&&Object.keys(p).length?f.set(n,p):(n.x.forEach(h),n.br.forEach(h))});let u=new Map([...f.values()].map(n=>{const h=Object.keys(n).sort();return h.length===1&&n[h[0]]===1?[n,h[0]]:[n,""+h.flatMap(p=>[p,n[p]]).join("")]}));{const n=new Map([...u.values()].map((h,p)=>[h,`c${p}`]));u=new Map([...u].map(([h,p])=>[h,n.get(p)]))}const r=a.map(n=>n.map(h=>{const p={id:h.id};return u.forEach((d,g)=>{d in p||(p[d]=Object.entries(g).reduce((x,[b,$])=>x+(h[b]??0)*$,0))}),p})),l=[...new Set(u.values())],c=new Map;for(const n of r)for(const h of l){const p=new Map;for(const x of n)p.set(x[h],(p.get(x[h])??0)+1);let[d,g]=[0,p.get(0)??0];for(const[x,b]of p)b>g&&([d,g]=[x,b]);if(d!==0){for(const x of n)x[h]-=d;c.set(h,(c.get(h)??0)+d)}for(const x of n)x[h]===0&&delete x[h]}let m=!!c.size;if(m||(m=[...f.keys()].some(n=>{if(n.op==="const"||n.op==="read")return!1;if(n.op==="sum"&&n.x.length===2){if(n.x[0].op==="const"&&n.x[1].op==="read")return!1;if(n.x[1].op==="const"&&n.x[0].op==="read")return!1}return!0})),!m)return;const i=new Map;for(const[n,h]of u){let p=L({[o]:h},void 0);n[w]+=c.get(h)??0,n[w]!==0&&(p=D(n[w],p)),i.set(n,p)}s.setCandidates(r),s.setNodes(v(e,(n,h)=>{const p=f.get(h);return p?i.get(p):n}))}function I(s){const e=s.values(),o=e.next().value;if(!o)return{};const a=Object.fromEntries(Object.entries(o).map(([t,f])=>[t,{min:f,max:f}]));for(const t of e){for(const[f,u]of Object.entries(a)){const r=t[f]??0;u.min>r&&(u.min=r),u.max<r&&(u.max=r)}for(const[f,u]of Object.entries(t))f in a||(a[f]={min:Math.min(0,u),max:Math.max(0,u)})}return a}function W(s,e,o){const a=new Map;return E(s,(t,f)=>{t.x.forEach(f),t.br.forEach(f);const u=t.x.map(i=>a.get(i)),r=u.map(i=>i.min),l=u.map(i=>i.max);function c(i,[n,h]){const p=te[i],d=[p([n.min,h.min],void 0),p([n.min,h.max],void 0),p([n.max,h.min],void 0),p([n.max,h.max],void 0)];return{min:Math.min(...d),max:Math.max(...d)}}let m;switch(t.op){case"const":typeof t.ex=="number"?m={min:t.ex,max:t.ex}:m={min:NaN,max:NaN};break;case"sum":m={min:r.reduce((i,n)=>i+n,0),max:l.reduce((i,n)=>i+n,0)};break;case"prod":m={min:1,max:1},m=u.reduce((i,n)=>c(t.op,[i,n]),m);break;case"min":case"max":m={min:Math[t.op](...r),max:Math[t.op](...l)};break;case"match":case"thres":m={min:Math.min(...r),max:Math.max(...l)};break;case"sumfrac":r[0]+r[1]>0||l[0]+l[1]<0?m=c(t.op,u):m={min:NaN,max:NaN};break;case"read":{m={min:0,max:0};for(const{[t.tag[e]]:i}of o)i&&(m.min+=i.min,m.max+=i.max);break}case"subscript":{if(typeof t.ex[0]!="number")m={min:NaN,max:NaN};else{m={min:1/0,max:-1/0};let{min:i,max:n}=a.get(t.br[0]);i=Math.max(0,Math.ceil(i)),n=Math.min(n,t.ex.length-1);for(let h=i;h<=n;h++){const p=t.ex[h];m.min>p&&(m.min=p),m.max<p&&(m.max=p)}m.min>m.max&&(m={min:NaN,max:NaN})}break}case"lookup":isNaN(r[0])&&isNaN(l[0])&&(r.splice(0,1),l.splice(0,1)),m={min:Math.min(...r),max:Math.max(...l)};break;case"custom":m=O[t.ex].range(u);break;default:N(t)}a.set(t,m)}),a}function ue(s,e,o){const a=new Map,t=[],f=new Map;function u(r,l){a.has(r)||a.set(r,{inc:!0,dec:!0});const c=a.get(r);if(l&&c.dec)c.dec=!1;else if(!l&&c.inc)c.inc=!1;else return;t.push({node:r,inc:l})}for(s.forEach(r=>u(r,!0));t.length;){const{node:r,inc:l}=t.pop();switch(r.op){case"read":f.set(r.tag[e],a.get(r));break;case"const":break;case"sum":case"min":case"max":r.x.forEach(c=>u(c,l));break;case"thres":{r.x.forEach(i=>u(i,l));const c=o.get(r.x[0]),m=o.get(r.x[1]);c.max>m.min&&(u(r.br[0],l),u(r.br[1],!l)),c.min<m.max&&(u(r.br[0],!l),u(r.br[1],l));break}case"sumfrac":{const[c,m]=r.x.map(i=>o.get(i));m.min<0&&u(r.x[0],!l),m.max>0&&u(r.x[0],l),c.min<0&&u(r.x[1],l),c.max>0&&u(r.x[1],!l);break}case"prod":{const c=o.get(r);if(c.min<0&&c.max>0)r.x.forEach(m=>u(m,!0)),r.x.forEach(m=>u(m,!1));else{const m=l===c.max>0;r.x.forEach(i=>u(i,m===o.get(i).max>0))}break}case"match":case"lookup":r.x.forEach(c=>u(c,l)),r.br.forEach(c=>u(c,!0)),r.br.forEach(c=>u(c,!1));break;case"subscript":{const{br:[c],ex:m}=r;if(typeof m[0]=="number"){let{min:i,max:n}=o.get(c);i=Math.max(0,Math.ceil(i)),n=Math.min(n,m.length-1);for(let h=i+1;h<=n;h++)if(m[h-1]<m[h]){u(c,l);break}for(let h=i+1;h<=n;h++)if(m[h-1]>m[h]){u(c,!l);break}}else u(c,!0),u(c,!1);break}case"custom":O[r.ex].monotonicity(r.x.map(c=>o.get(c))).forEach((c,m)=>{c.inc||u(r.x[m],!l),c.dec||u(r.x[m],l)});break;default:N(r)}}return f}function A(s){return s.reduce((e,o)=>e*o.length,1)}function me(s,e,o){const a=[],t=[],f=[];for(const[i,n]of o)n.inc?t.push(i):n.dec?f.push(i):a.push(i);if(a.length)for(let i=0,n=e.length;i<n;i++){const h=e[i],p=a.find(g=>h[g].min!==h[g].max);if(p===void 0)continue;const d=new Map;for(const g of s[i]){const x=d.get(g[p]);x?x.push(g):d.set(g[p],[g])}return[...d.values()].sort((g,x)=>x.length-g.length).map(g=>{const x=[...s];return x[i]=g,x})}const u=new Map([...t.map(i=>[i,Math.random()]),...f.map(i=>[i,-Math.random()])]),r=s.reduce((i,n,h,p)=>p[i].length<n.length?h:i,0),l=s[r].map(i=>{const n=Object.entries(i).reduce((h,[p,d])=>typeof d=="number"?h+d*u.get(p):h,0);return[i,n]});l.sort((i,n)=>i[1]-n[1]);const c=Math.ceil(l.length/4),m=[];for(let i=0;i<l.length;i+=c){const n=l.slice(i,i+c).map(([p])=>p),h=[...s];h[r]=n,m.push(h)}return m}const B=2e4,fe=3e3;class le{constructor(e){this.subworks=[],this.results=[],this.progress={computed:0,failed:0,skipped:0,remaining:0},this.nodes=e.nodes,this.minimum=e.minimum,this.topN=e.topN,this.candidates=e.candidates.map(o=>new Map(o.map(a=>[a.id,a])))}add(e){const{subworks:o,progress:a,candidates:t}=this;e.forEach(f=>a.remaining+=f.count),o.unshift(...e.map(({ids:f,count:u})=>({nodes:this.nodes,minimum:this.minimum,candidates:f.map((r,l)=>r.map(c=>t[l].get(c))),count:u}))),o.length===e.length&&this.spreadSubworks()}steal(e){const{subworks:o,progress:a}=this;e=Math.floor(Math.max(e,B));let t=a.remaining-e;if(t<=0)return[];const f=o.findIndex(r=>(t-=r.count)<=0)+1,u=o.splice(0,f||o.length);return a.remaining=e+t,u.map(({candidates:r,count:l})=>({ids:r.map(c=>c.map(m=>m.id)),count:l}))}hasWork(){return!!this.subworks.length}process(){const e=this.subworks.pop();if(!e)return;this.spreadSubworks();const{progress:o,results:a}=this,{nodes:t,minimum:f,candidates:u,count:r}=e;f[0]=this.minimum[0];const l=H(t,"q",u.length,{});for(const c of P(u)){const m=l(c);f.some((i,n)=>n&&m[n]<i)?o.failed+=1:m[0]>=f[0]&&a.push({value:m[0],ids:c.map(i=>i.id)})}o.computed+=r,o.remaining-=r,a.length>fe&&this.clean()}setOptThreshold(e){this.minimum[0]=e,this.results=this.results.filter(o=>o.value>=e)}resetProgress(){this.clean();const{progress:e}=this,o={builds:[...this.results],...e};return e.computed=0,e.failed=0,e.skipped=0,o}clean(){this.results.sort((e,o)=>o.value-e.value).splice(this.topN),this.results.length===this.topN&&(this.minimum[0]=this.results[this.topN-1].value)}spreadSubworks(){const{subworks:e,progress:o}=this;for(;e.length;){const a=e.pop();a.minimum[0]=this.minimum[0];const{nodes:t,candidates:f,minimum:u,cndRanges:r,monotonicities:l}=ne(a.nodes,a.candidates,"q",a.minimum,this.topN),c=A(f);if(o.skipped+=a.count-c,o.remaining-=a.count-c,!!c){if(a.count<=B){e.push(a);return}e.push(...me(f,r,l).map(m=>{const i=A(m);return{nodes:t,candidates:m,minimum:u,count:i}}))}}}}function*P(s,e=Array(s.length),o=s.length-1){if(o===-1)return yield e;for(const a of s[o])e[o]=a,yield*P(s,e,o-1)}const he=20;onmessage=async({data:s})=>{try{const e=await pe(s);e&&postMessage(e)}catch(e){postMessage({ty:"err",msg:`${e}`})}};let k;async function pe(s){switch(s.ty){case"init":if(k)throw new Error("Worker is already initialized");return k=new le(s),{ty:"progress",...k.resetProgress()};case"config":k.setOptThreshold(s.threshold);return;case"work?":{const e=k.steal(s.maxKeep);return e.length?{ty:"add",works:e}:void 0}case"add":return k.add(s.works),de(),{ty:"recv"}}}let M;async function de(){if(M===void 0){M=Date.now();do{await new Promise(e=>setTimeout(e));const s=Date.now();(s>=M||k.subworks.length<4)&&(M=s+he,postMessage({ty:"progress",...k.resetProgress()})),k.process()}while(k.hasWork());postMessage({ty:"progress",...k.resetProgress()}),M=void 0}}})();
